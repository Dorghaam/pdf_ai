// Functions for interacting with pgvector in Supabase
import { createAdminClient } from './supabase/admin'; // For server-side calls
import { embedTextChunks } from './openai'; // Assuming embedTextChunks can take a single string too

// TODO: Define your table and column names
const CHUNKS_TABLE_NAME = 'document_chunks'; // Example table name
const EMBEDDING_COLUMN_NAME = 'embedding'; // Example embedding column name
const CONTENT_COLUMN_NAME = 'content';
const DOCUMENT_ID_COLUMN_NAME = 'document_id';
const MATCH_FUNCTION_NAME = 'match_document_chunks'; // Example Supabase RPC function for matching

interface Chunk {
  id?: string; // Auto-generated by Supabase
  document_id: string;
  content: string;
  embedding: number[];
  // Add other metadata like page_number, chunk_index, etc.
  page_number?: number;
  metadata?: Record<string, any>;
}

interface ChunkToSave extends Omit<Chunk, 'embedding'> {
  embedding: number[]; // Ensure embedding is provided for saving
}


/**
 * Saves processed chunks with their embeddings to the vector store.
 */
export async function saveChunksToVectorStore(documentId: string, chunksWithEmbeddings: Array<Omit<Chunk, 'document_id' | 'id' | 'embedding'> & { embedding: number[] }>): Promise<void> {
  const supabase = createAdminClient();
  const recordsToInsert = chunksWithEmbeddings.map(chunk => ({
    document_id: documentId,
    content: chunk.content,
    embedding: chunk.embedding,
    page_number: chunk.page_number, // Optional
    metadata: chunk.metadata,     // Optional
  }));

  const { error } = await supabase.from(CHUNKS_TABLE_NAME).insert(recordsToInsert);

  if (error) {
    console.error('Error saving chunks to vector store:', error);
    throw new Error('Failed to save chunks to Supabase.');
  }
  console.log(`Successfully saved ${recordsToInsert.length} chunks for document ${documentId}.`);
}

/**
 * Searches for similar chunks in the vector store based on a query.
 */
export async function searchSimilarChunks(
  documentId: string,
  queryText: string,
  options: { limit: number } = { limit: 5 }
): Promise<Chunk[]> {
  const supabase = createAdminClient(); // Or regular client if RLS allows and called from secure context

  // 1. Embed the query text
  const queryEmbeddingResponse = await embedTextChunks([queryText]); // Reusing embedTextChunks
  if (!queryEmbeddingResponse || queryEmbeddingResponse.length === 0) {
    throw new Error('Failed to generate embedding for query.');
  }
  const queryEmbedding = queryEmbeddingResponse[0].embedding;


  // 2. Call Supabase RPC function to perform similarity search
  //    This assumes you have a function like `match_document_chunks` defined in your Supabase SQL.
  //    See supabase/migrations/0000_initial_schema.sql for an example.
  const { data, error } = await supabase.rpc(MATCH_FUNCTION_NAME, {
    query_embedding: queryEmbedding,
    match_threshold: 0.78, // TODO: Tune this threshold
    match_count: options.limit,
    filter_document_id: documentId, // Pass the document_id to filter by
  });

  if (error) {
    console.error('Error searching for similar chunks:', error);
    throw new Error('Failed to search for similar chunks in Supabase.');
  }

  return data as Chunk[] || []; // Ensure it returns an array
}